Question 2

(* Non-tail-recursive version *)
let rec makeList n =
  if n < 0 then
    raise (Invalid_argument "n must be non-negative")
  else if n = 0 then
    []
  else
    makeList (n - 1) @ [n]

(* Tail-recursive version *)
let makeList_tail n =
  let rec aux n acc =
    if n < 0 then
      raise (Invalid_argument "n must be non-negative")
    else if n = 0 then
      acc
    else
      aux (n - 1) (n :: acc)
  in
  aux n []

(* Calling the non-tail-recursive version *)
let result1 = makeList 4
(* result1 will be [1; 2; 3; 4] *)

(* Calling the tail-recursive version *)
let result2 = makeList_tail 4
(* result2 will be [1; 2; 3; 4] *)

Question 4

(* Define the type for the binary tree *)
type 'a tree =
  | Empty
  | Node of 'a * 'a tree * 'a tree

(* Function to count the number of leaves in a binary tree *)
let rec count_leaves tree =
  match tree with
  | Empty -> 0
  | Node (_, Empty, Empty) -> 1
  | Node (_, left, right) -> count_leaves left + count_leaves right

(* Example usage *)
let example_tree = 
  Node (1, 
    Node (2, Empty, Empty), 
    Node (3, 
      Node (4, Empty, Empty), 
      Empty))

let num_leaves = count_leaves example_tree
(* num_leaves will be 2 *)

Question 6

(* Function to perform pre-order traversal of a binary tree *)
let rec preorder_traversal tree =
  match tree with
  | Empty -> []
  | Node (value, left, right) ->
      [value] @ (preorder_traversal left) @ (preorder_traversal right)

(* Example usage *)
let preorder_list = preorder_traversal example_tree
(* preorder_list will be [1; 2; 3; 4] *)

question 8

The expression does not reduce to a finite form and is considered divergent.

(λy. y y) ((λy. y y))


question 10

(λx. t x x) (λx. t x x)

similar to the previous one, is also divergent and does not reduce to a normal form.

question 12

-- Function to produce the list of divisors of a given positive integer
divisors :: Int -> [Int]
divisors n = [x | x <- [1..n], n `mod` x == 0]

question 14

-- Function to check if a number is prime
isPrime :: Int -> Bool
isPrime n
  | n < 2     = False
  | otherwise = null [x | x <- [2..(n-1)], n `mod` x == 0]

-- Infinite list of prime numbers
primes :: [Int]
primes = [x | x <- [2..], isPrime x]


question 16

-- Function to check if a number is perfect
isPerfect :: Int -> Bool
isPerfect n = sum (init (divisors n)) == n

-- Function to produce the list of all perfect numbers up to a given integer
perfs :: Int -> [Int]
perfs m = [x | x <- [1..m], isPerfect x]


-- Example usage
main :: IO ()
main = do
  let n = 12
  print (divisors n)  -- Output will be [1, 2, 3, 4, 6, 12]
  print (take 10 primes)  -- Output will be the first 10 prime numbers: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
  print (perfs 10000)  -- Output will be the list of perfect numbers up to 10000: [6, 28, 496, 8128]
